<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>geotiff.js</h1>
<p><a href="https://github.com/geotiffjs/geotiff.js/actions/workflows/ci.yml"><img src="https://github.com/geotiffjs/geotiff.js/actions/workflows/ci.yml/badge.svg?branch=master" alt="Node.js CI"></a> <a href="https://badge.fury.io/js/geotiff"><img src="https://badge.fury.io/js/geotiff.svg" alt="npm version"></a> <a href="https://gitter.im/geotiffjs/Lobby"><img src="https://badges.gitter.im/geotiffjs/geotiff.js.png" alt="Gitter chat"></a></p>
<p>Read (geospatial) metadata and raw array data from a wide variety of different
(Geo)TIFF files types.</p>
<h2>Features</h2>
<p>Currently available functionality:</p>
<ul>
<li>Parsing TIFFs from various sources:
<ul>
<li>remote (via <code>fetch</code> or XHR)</li>
<li>from a local <code>ArrayBuffer</code></li>
<li>from the filesystem (on Browsers using the <code>FileReader</code> and on node using the filesystem functions)</li>
</ul>
</li>
<li>Parsing the headers of all possible TIFF files</li>
<li>Rudimentary extraction of geospatial metadata</li>
<li>Reading raster data from:
<ul>
<li>stripped images</li>
<li>tiled images</li>
<li>band interleaved images</li>
<li>pixel interleaved images</li>
</ul>
</li>
<li>Supported data-types:
<ul>
<li>(U)Int8/16/32</li>
<li>UInt1-31 (with some drawbacks)</li>
<li>Float16/32/64</li>
</ul>
</li>
<li>Enabled compressions:
<ul>
<li>no compression</li>
<li>Packbits</li>
<li>LZW</li>
<li>Deflate (with floating point or horizontal predictor support)</li>
<li>JPEG</li>
<li>LERC (with additional Deflate compression support)</li>
</ul>
</li>
<li>Automatic selection of overview level to read from</li>
<li>Subsetting via an image window or bounding box and selected bands</li>
<li>Reading of samples into separate arrays or a single pixel-interleaved array</li>
<li>Configurable tile/strip cache</li>
<li>Configurable Pool of workers to increase decoding efficiency</li>
<li>Utility functions for geospatial parameters (Bounding Box, Origin, Resolution)</li>
<li>Limited <a href="http://bigtiff.org/#FILE_FORMAT">bigTIFF</a> support</li>
<li>Automated testing via PhantomJS</li>
</ul>
<p>Further documentation can be found <a href="https://geotiffjs.github.io/geotiff.js/">here</a>.</p>
<h2>Example Usage</h2>
<p>Geotiff gives you access to all GeoTIFF metadata, but does not offer any one specific higher level API (such as GDAL) for things like transforms or data extraction. However, you can write your own higher level API using this library, given your specific dataset needs.</p>
<p>As an example, here is how you would resolve GPS coordinates to elevation in a GeoTIFF that encodes WGS-84 compliant geo data:</p>
<pre class="prettyprint source lang-js"><code>import { fromUrl, fromArrayBuffer, fromBlob  } from &quot;geotiff&quot;;

const lerp = (a, b, t) => (1 - t) * a + t * b;

function transform(a, b, M, roundToInt = false) {
  const round = (v) => (roundToInt ? v | 0 : v);
  return [
    round(M[0] + M[1] * a + M[2] * b),
    round(M[3] + M[4] * a + M[5] * b),
  ];
}

// Load our data tile from url, arraybuffer, or blob, so we can work with it:
const tiff = await fromArrayBuffer(...);
const image = await tiff.getImage(); // by default, the first image is read.

// Construct the WGS-84 forward and inverse affine matrices:
const { ModelPixelScale: s, ModelTiepoint: t } = image.fileDirectory;
let [sx, sy, sz] = s;
let [px, py, k, gx, gy, gz] = t;
sy = -sy; // WGS-84 tiles have a &quot;flipped&quot; y component

const pixelToGPS = [gx, sx, 0, gy, 0, sy];
console.log(`pixel to GPS transform matrix:`, pixelToGPS);

const gpsToPixel = [-gx / sx, 1 / sx, 0, -gy / sy, 0, 1 / sy];
console.log(`GPS to pixel transform matrix:`, gpsToPixel);

// Convert a GPS coordinate to a pixel coordinate in our tile:
const [gx1, gy1, gx2, gy2] = image.getBoundingBox();
const lat = lerp(gy1, gy2, Math.random());
const long = lerp(gx1, gx2, Math.random());
console.log(`Looking up GPS coordinate (${lat.toFixed(6)},${long.toFixed(6)})`);

const [x, y] = transform(long, lat, gpsToPixel, true);
console.log(`Corresponding tile pixel coordinate: [${x}][${y}]`);

// And as each pixel in the tile covers a geographic area, not a single
// GPS coordinate, get the area that this pixel covers:
const gpsBBox = [transform(x, y, pixelToGPS), transform(x + 1, y + 1, pixelToGPS)];
console.log(`Pixel covers the following GPS area:`, gpsBBox);

// Finally, retrieve the elevation associated with this pixel's geographic area:
const rasters = await image.readRasters();
const { width, [0]: raster } = rasters;
const elevation = raster[x + y * width];
console.log(`The elevation at (${lat.toFixed(6)},${long.toFixed(6)}) is ${elevation}m`);
</code></pre>
<h2>Advanced Example Usage</h2>
<p>For more advanced examples of <code>geotiff</code> in larger codebases, please have a look at the following projects:</p>
<ul>
<li><a href="http://www.youtube.com/watch?v=E6kFLtKgeJ8">Slice view using Cesium.js (TAMP project)</a></li>
</ul>
<p><a href="http://www.youtube.com/watch?v=E6kFLtKgeJ8"><img src="http://img.youtube.com/vi/E6kFLtKgeJ8/0.jpg" alt="3D slice view"></a></p>
<ul>
<li><a href="https://bl.ocks.org/mbostock/83c0be21dba7602ee14982b020b12f51">Contour generation using d3-contour</a></li>
</ul>
<p><a href="https://bl.ocks.org/mbostock/83c0be21dba7602ee14982b020b12f51"><img src="https://user-images.githubusercontent.com/482265/112866402-0b219880-90ba-11eb-9dda-5f1d9ed9bafc.jpg" alt="contour"></a></p>
<h2>Setup</h2>
<p>To setup the repository do the following steps:</p>
<pre class="prettyprint source lang-bash"><code># clone repo
git clone https://github.com/constantinius/geotiff.js.git
cd geotiff.js/

# install development dependencies
npm install
</code></pre>
<h2>Testing and Building</h2>
<p>In order to run the tests you first have to set up the test data. This requires
the <a href="http://gdal.org/">GDAL</a> and <a href="http://imagemagick.org/">ImageMagick</a> tools.
Installation of these tools varies according to the operating system, the
following listing shows the installation on Ubuntu (using the ubuntugis-unstable
repository):</p>
<pre class="prettyprint source lang-bash"><code>sudo add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable
sudo apt-get update
sudo apt-get install -y gdal-bin imagemagick
</code></pre>
<p>To install GDAL and ImageMagick on MacOS X, please use <a href="https://brew.sh/">Homebrew</a>. The setup script also needs <code>wget</code> on MacOS X</p>
<pre class="prettyprint source lang-bash"><code>brew install wget gdal imagemagick
</code></pre>
<p>When GDAL and ImageMagick is installed, the test data setup script can be run:</p>
<pre class="prettyprint source lang-bash"><code>cd test/data
sh setup_data.sh
cd -
</code></pre>
<p>To test the library (using PhantomJS, karma, mocha and chai) do the following:</p>
<pre class="prettyprint source lang-bash"><code>npm test
</code></pre>
<p>To do some in-browser testing do:</p>
<pre class="prettyprint source lang-bash"><code>npm run dev
</code></pre>
<p>and navigate to <code>http://localhost:8090/test/</code></p>
<p>To build the library do:</p>
<pre class="prettyprint source lang-bash"><code>npm run build
</code></pre>
<p>The output is written to <code>dist-browser/main.js</code> and <code>dist-node/main.js</code>.</p>
<h2>Install</h2>
<p>You can install geotiff.js using npm:</p>
<pre class="prettyprint source"><code>npm install geotiff
</code></pre>
<p>or you can use the prebuilt version with a CDN:</p>
<pre class="prettyprint source lang-html"><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/geotiff&quot;>&lt;/script>
</code></pre>
<h2>Usage</h2>
<p>geotiff.js works with both <code>require</code>, <code>import</code> and the global variable <code>GeoTIFF</code>:</p>
<pre class="prettyprint source lang-javascript"><code>const GeoTIFF = require('geotiff');
const { fromUrl, fromUrls, fromArrayBuffer, fromBlob } = GeoTIFF;

// or
import GeoTIFF, { fromUrl, fromUrls, fromArrayBuffer, fromBlob } from 'geotiff';
</code></pre>
<p>or:</p>
<pre class="prettyprint source lang-html"><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/geotiff&quot;>&lt;/script>
&lt;script>
  console.log(GeoTIFF);
&lt;/script>
</code></pre>
<p>To parse a GeoTIFF, first a data source is required. To help with the development,
there are shortcuts available. The following creates a source that reads from a
remote GeoTIFF referenced by a URL:</p>
<pre class="prettyprint source lang-javascript"><code>fromUrl(someUrl)
  .then(tiff => { /* ... */});

// or when using async/await
(async function() {
  const tiff = await fromUrl(someUrl);
  // ...
})()
</code></pre>
<p>Note: the interactions with geotiff.js objects are oftentimes asynchronous. For
the sake of brevity we will only show the async/await syntax and not the
<code>Promise</code> based one in the following examples.</p>
<p>Accessing remote images is just one way to open TIFF images with geotiff.js. Other
options are reading from a local <code>ArrayBuffer</code>:</p>
<pre class="prettyprint source lang-javascript"><code>// using local ArrayBuffer
const response = await fetch(someUrl);
const arrayBuffer = await response.arrayBuffer();
const tiff = await fromArrayBuffer(arrayBuffer);
</code></pre>
<p>or a <code>Blob</code>/<code>File</code>:</p>
<pre class="prettyprint source lang-html"><code>&lt;input type=&quot;file&quot; id=&quot;file&quot;>
&lt;script>
  const input = document.getElementById('file');
  input.onchange = async function() {
    const tiff = await fromBlob(input.files[0]);
  }
&lt;/script>
</code></pre>
<p>Now that we have opened the TIFF file, we can inspect it. The TIFF is structured
in a small header and a list of one or more images (Image File Directory, IFD to
use the TIFF nomenclature). To get one image by index the <code>getImage()</code> function
must be used. This is again an asynchronous operation, as the IFDs are loaded
lazily:</p>
<pre class="prettyprint source lang-javascript"><code>const image = await tiff.getImage(); // by default, the first image is read.
</code></pre>
<p>Now that we have obtained a <code>GeoTIFFImage</code> object we can inspect its metadata
(like size, tiling, number of samples, geographical information, etc.). All
the metadata is parsed once the IFD is first parsed, thus the access to that
is synchronous:</p>
<pre class="prettyprint source lang-javascript"><code>const width = image.getWidth();
const height = image.getHeight();
const tileWidth = image.getTileWidth();
const tileHeight = image.getTileHeight();
const samplesPerPixel = image.getSamplesPerPixel();

// when we are actually dealing with geo-data the following methods return
// meaningful results:
const origin = image.getOrigin();
const resolution = image.getResolution();
const bbox = image.getBoundingBox();
</code></pre>
<p>The actual raster data is not fetched and parsed automatically. This is because
it is usually much more spacious and the decoding of the pixels can be time
consuming due to the necessity of decompression.</p>
<p>To read a whole image into one big array of arrays the following method call can be used:</p>
<pre class="prettyprint source lang-javascript"><code>const data = await image.readRasters();
</code></pre>
<p>For convenience the result always has a <code>width</code> and <code>height</code> attribute:</p>
<pre class="prettyprint source lang-javascript"><code>const data = await image.readRasters();
const { width, height } = data;
</code></pre>
<p>By default, the raster is split to a separate array for each component. For an RGB image
for example, we'd get three arrays, one for red, green and blue.</p>
<pre class="prettyprint source lang-javascript"><code>const [red, green, blue] = await image.readRasters();
</code></pre>
<p>If we want instead all the bands interleaved in one big array, we have to pass the
<code>interleave: true</code> option:</p>
<pre class="prettyprint source lang-javascript"><code>const [r0, g0, b0, r1, g1, b1, ...] = await image.readRasters({ interleave: true });
</code></pre>
<p>If we are only interested in a specific region of the image, the <code>window</code> option can be
used to limit reading in that bounding box. Note: the bounding box is in 'image coordinates'
not geographical ones:</p>
<pre class="prettyprint source lang-javascript"><code>const left = 50;
const top = 10;
const right = 150;
const bottom = 60;

const data = await image.readRasters({ window: [left, top, right, bottom] });
</code></pre>
<p>This image window can go beyond the image bounds. In that case it might be usefull to supply
a <code>fillValue: value</code> option (can also be an array, one value for each sample).</p>
<p>It is also possible to just read specific samples for each pixel. For example, we can only
read the red component from an RGB image:</p>
<pre class="prettyprint source lang-javascript"><code>const [red] = await image.readRasters({ samples: [0] });
</code></pre>
<p>When you want your output in a specific size, you can use the <code>width</code> and <code>height</code> options.
This defaults of course to the size of your supplied <code>window</code> or the image size if no
<code>window</code> was supplied.</p>
<p>As the data now needs to be resampled, a <code>resampleMethod</code> can be specified. This defaults to
the nearest neighbour method, but also the <code>'bilinear'</code> method is supported:</p>
<pre class="prettyprint source lang-javascript"><code>const data = await image.readRasters({ width: 40, height: 40, resampleMethod: 'bilinear' });
</code></pre>
<h3>Using decoder pools to improve parsing performance</h3>
<p>Decoding compressed images can be a time consuming process. To minimize this
geotiff.js provides the <code>Pool</code> mechanism which uses WebWorkers to split the amount
of work on multiple 'threads'.</p>
<pre class="prettyprint source lang-javascript"><code>const pool = new GeoTIFF.Pool();
const data = await image.readRasters({ pool });
</code></pre>
<p>It is possible to provide a pool size (i.e: number of workers), by default the number
of available processors is used.</p>
<h3>Dealing with visual data</h3>
<p>The TIFF specification provides various ways to encode visual data. In the
specification this is called photometric interpretation. The simplest case we
already dealt with is the RGB one. Others are grayscale, paletted images, CMYK,
YCbCr, and CIE L<em>a</em>b.</p>
<p>geotiff.js provides a method to automatically convert these images to RGB:
<code>readRGB()</code>. This method is very similar to the <code>readRasters</code> method with
distinction that the <code>interleave</code> option is now always <code>true</code> and the
<code>samples</code> are automatically chosen.</p>
<pre class="prettyprint source lang-javascript"><code>const rgb = await image.readRGB({
  // options...
});
</code></pre>
<h3>Automatic image selection (experimental)</h3>
<p>When dealing with images that have internal (or even external, see the next section)
overviews, <code>GeoTIFF</code> objects provide a separate <code>readRasters</code> method. This method
works very similar to the method on the <code>GeoTIFFImage</code> objects with the same name.
By default, it uses the larges image available (highest resolution), but when either
<code>width</code>, <code>height</code>, <code>resX</code>, or <code>resY</code> are specified, then the best fitting image will
be used for reading.</p>
<p>Additionally, it allows the <code>bbox</code> instead of the <code>window</code> parameter. This works
similarly, but uses geographic coordinates instead of pixel ones.</p>
<pre class="prettyprint source lang-javascript"><code>const data = await tiff.readRasters({
  bbox: [10.34, 57.28, 13.34, 60.23],
  resX: 0.1,
  resY: 0.1
});
</code></pre>
<h3>External overviews</h3>
<p>Especially for certain kinds of high resolution images it is not uncommon to separate
the highest resolution from the lower resolution overviews (usually using the <code>.ovr</code>
extension). With geotiff.js it is possible to use files of this setup, just as you
would use single-file images by taking advantage of the <code>MultiGeoTIFF</code> objects. They
behave exactly the same as the before mentioned <code>GeoTIFF</code> objects: you can select
images by index or read data using <code>readRasters</code>. Toget such a file use the <code>fromUrls</code>
factory function:</p>
<pre class="prettyprint source lang-javascript"><code>const multiTiff = await fromUrls(
  'LC08_L1TP_189027_20170403_20170414_01_T1_B3.TIF',
  ['LC08_L1TP_189027_20170403_20170414_01_T1_B3.TIF.ovr']
);
</code></pre>
<h3>AbortController Support</h3>
<p>Geotiff.js supports the use of <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController"><code>AbortController</code>s</a>. Calls to <code>getRasters</code>, <code>readRGB</code> and <code>getTileOrStrip</code> will throw an <code>Error</code> with name <code>AbortSignal</code> similar to the browser's <code>fetch</code> behavior.</p>
<pre class="prettyprint source lang-javascript"><code>const tiff = await fromUrl(source);
const abortController = new AbortController();
const { signal } = abortController;
abortController.abort();
try {
  const data = await tiff.readRasters({ signal });
} catch(e) {
  if (err.name === 'AbortError') {
    // do stuff
  }
}
</code></pre>
<h3>Writing GeoTIFFs (Beta Version)</h3>
<p>You can create a binary representation of a GeoTIFF using <code>writeArrayBuffer</code>.
This function returns an ArrayBuffer which you can then save as a .tif file.
:warning: writeArrayBuffer currently writes the values uncompressed</p>
<pre class="prettyprint source lang-javascript"><code>import GeoTIFF, { writeArrayBuffer } from 'geotiff';

const values = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const metadata = {
  height: 3,
  width: 3
};
const arrayBuffer = await writeArrayBuffer(values, metadata);
</code></pre>
<p>You can also customize the metadata using names found in the <a href="https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml">TIFF Spec</a> and <a href="https://cdn.earthdata.nasa.gov/conduit/upload/6852/geotiff-1.8.1-1995-10-31.pdf">GeoTIFF spec</a>.</p>
<pre class="prettyprint source lang-javascript"><code>import { writeArrayBuffer } from 'geotiff';

const values = [1, 2, 3, 4, 5, 6, 7, 8, 9];
const metadata = {
  GeographicTypeGeoKey: 4326,
  height: 3,
  ModelPixelScale: [0.031355, 0.031355, 0],
  ModelTiepoint: [0, 0, 0, 11.331755000000001, 46.268645, 0],
  width: 3
};
const arrayBuffer = await writeArrayBuffer(values, metadata);
</code></pre>
<h2>What to do with the data?</h2>
<p>There is a nice HTML 5/WebGL based rendering library called
<a href="https://github.com/santilland/plotty">plotty</a>, that allows for some really nice
on the fly rendering of the data contained in a GeoTIFF.</p>
<pre class="prettyprint source lang-html"><code>&lt;canvas id=&quot;plot&quot;>&lt;/canvas>
&lt;script>
  // ...

  (async function() {
    const tiff = await fromUrl(url);
    const image = await tiff.getImage();
    const data = await image.readRasters();

    const canvas = document.getElementById(&quot;plot&quot;);
    const plot = new plotty.plot({
      canvas,
      data: data[0],
      width: image.getWidth(),
      height: image.getHeight(),
      domain: [0, 256],
      colorScale: &quot;viridis&quot;
    });
    plot.render();
  })();
&lt;/script>
</code></pre>
<p>There's also a library called <a href="https://github.com/matafokka/geotiff-geokeys-to-proj4">geotiff-geokeys-to-proj4</a>, that allows for reprojecting pixel coordinates and, therefore, consuming geospatial data contained in GeoTIFF.</p>
<h2>BigTIFF support</h2>
<p>geotiff.js has a limited support for files in the BigTIFF format. The limitations
originate in the capabilities of current JavaScript implementations regarding
64 bit integer parsers and structures: there are no functions to read 64 bit
integers from a stream and no such typed arrays. As BigTIFF relies on 64 bit
offsets and also allows tag values of those types. In order to still provide
a reasonable support, the following is implemented:</p>
<ul>
<li>64 bit integers are read as two 32 bit integers and then combined. As
numbers in JavaScript are typically implemented as 64 bit floats, there
might be inaccuracies for <em>very</em> large values.</li>
<li>For 64 bit integer arrays, the default <code>Array</code> type is used. This might
cause problems for some compression algorithms if those arrays are used for
pixel values.</li>
</ul>
<h2>n-bit Support</h2>
<p>geotiff.js has some n-bit support which means that it supports unsigned integer
data reading with each element using a non-multiple of 8 bit depth. This only
works with band interleaved images (see
<a href="https://github.com/geotiffjs/geotiff.js/issues/202">this related issue</a>).</p>
<h2>Planned stuff:</h2>
<ul>
<li>Better support of geospatial parameters:
<ul>
<li>WKT representation</li>
</ul>
</li>
</ul>
<h2>Known Issues</h2>
<p>The open issues can be found on <a href="https://github.com/geotiffjs/geotiff.js/issues">GitHub</a>.</p>
<h2>Contribution</h2>
<p>If you have an idea, found a bug or have a remark, please open a ticket, we will
look into it ASAP.</p>
<p>Pull requests are welcome as well!</p>
<h2>Community Packages</h2>
<p>A list of community packages can be found in <a href="COMMUNITY.md">COMMUNITY.md</a></p>
<h2>Acknowledgements</h2>
<p>This library was inspired by
<a href="https://github.com/xlhomme/GeotiffParser.js">GeotiffParser</a>. It provided a
great starting point, but lacked the capabilities to read the raw raster data
which is the aim of geotiff.js.</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-geotiff.html">geotiff</a></li><li><a href="module-geotiffimage.html">geotiffimage</a></li><li><a href="module-pool.html">pool</a></li><li><a href="module-resample.html">resample</a></li></ul><h3>Classes</h3><ul><li><a href="ArrayBufferSource.html">ArrayBufferSource</a></li><li><a href="BaseClient.html">BaseClient</a></li><li><a href="BaseResponse.html">BaseResponse</a></li><li><a href="BaseSource.html">BaseSource</a></li><li><a href="Block.html">Block</a></li><li><a href="BlockedSource.html">BlockedSource</a></li><li><a href="BlockedSource_BlockedSource.html">BlockedSource</a></li><li><a href="BlockGroup.html">BlockGroup</a></li><li><a href="CustomAggregateError.html">CustomAggregateError</a></li><li><a href="DummyLogger.html">DummyLogger</a></li><li><a href="FetchClient.html">FetchClient</a></li><li><a href="FetchResponse.html">FetchResponse</a></li><li><a href="FileReaderSource.html">FileReaderSource</a></li><li><a href="FileSource.html">FileSource</a></li><li><a href="HttpClient.html">HttpClient</a></li><li><a href="HttpResponse.html">HttpResponse</a></li><li><a href="JpegStreamReader.html">JpegStreamReader</a></li><li><a href="module.exports.html">exports</a></li><li><a href="module-geotiffimage-GeoTIFFImage.html">GeoTIFFImage</a></li><li><a href="module-geotiff-GeoTIFF.html">GeoTIFF</a></li><li><a href="module-geotiff-GeoTIFFBase.html">GeoTIFFBase</a></li><li><a href="module-geotiff-GeoTIFFImageIndexError.html">GeoTIFFImageIndexError</a></li><li><a href="module-geotiff-ImageFileDirectory.html">ImageFileDirectory</a></li><li><a href="module-geotiff-MultiGeoTIFF.html">MultiGeoTIFF</a></li><li><a href="module-pool-Pool.html">Pool</a></li><li><a href="RemoteSource.html">RemoteSource</a></li><li><a href="XHRClient.html">XHRClient</a></li><li><a href="XHRResponse.html">XHRResponse</a></li></ul><h3>Global</h3><ul><li><a href="global.html#makeFileReaderSource">makeFileReaderSource</a></li><li><a href="global.html#makeRemoteSource">makeRemoteSource</a></li><li><a href="global.html#parseByteRanges">parseByteRanges</a></li><li><a href="global.html#parseContentRange">parseContentRange</a></li><li><a href="global.html#parseContentType">parseContentType</a></li><li><a href="global.html#parseHeaders">parseHeaders</a></li><li><a href="global.html#registerTag">registerTag</a></li><li><a href="global.html#setLogger">setLogger</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Wed Apr 23 2025 08:37:48 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>